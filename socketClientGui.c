#include <stdio.h>#include <winsock2.h>#include <windows.h>#include <tchar.h>#include <winnt.h>#include <commctrl.h>#include <MMSystem.h> // PlaySound()#include <time.h>#include <sys/time.h>#include <pthread.h>#include "properties.h"#include "resource/resource.h"#include "log.h"#include "message.h"#include "socketCommunication.h"/***** ウィンドウ(コントロール)の識別ID ***************************//** エディットボックス **/// メッセージ#define CTL_ID_EDIT_MSG 0/** ボタン **/// 送信#define CTL_ID_BTN_SEND 10// 終了#define CTL_ID_BTN_EXIT 11/** リストビュー **/// チャット一覧#define CTL_ID_LIST_MSG 30// チャット参加者一覧#define CTL_ID_LIST_MEMBER 31#define NOT_SPLIT_STATUS_BAR 255/*******************************************************************/// ウィンドウクラスの名前#define CLASS_NAME_CHAT_WINDOW TEXT("CHATWINDOW")#define SETTING_FILE_PATH TEXT("C:\\Users\\sgym2835win\\workspace_clang\\SocketChatClientGUI\\user.properties")static HINSTANCE hInst;static HWND hStatus;// チャット一覧HWND hListMsg;HWND hListMember;// BGM再生中かstatic int isPlayedBGM = 0;// ユーザ名static TCHAR userName[1024];int threadStatus = 0;/* プロトタイプ宣言 */int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow);LRESULT CALLBACK WndProc(HWND hWnd , UINT msg , WPARAM wp , LPARAM lp);void InitControls(HWND hWnd);void sendbtn_click(HWND hWnd);void SetStatusText(TCHAR *msg);int startThread(void);void watchServerMessage(void);#ifdef _UNICODEint main(int argc, char **argv){     HINSTANCE hInstance = GetModuleHandle(NULL);    int retval = 0;    retval = _tWinMain(hInstance, NULL, TEXT(""), SW_SHOW);    return retval;}#endif /* _UNICODE */int APIENTRY _tWinMain(HINSTANCE hInstance,                     HINSTANCE hPrevInstance,					 LPTSTR lpCmdLine,                     int nCmdShow) {	HWND hWnd;	MSG msg;	WNDCLASS wndCls;	hInst = hInstance;	/*** ウィンドウクラスの設定 ***/	// http://www-higashi.ist.osaka-u.ac.jp/~k-maeda/vcpp/sec1-3wnddetail.html	// http://doremi.s206.xrea.com/c/window.html	wndCls.style	      = CS_HREDRAW | CS_VREDRAW;                            // ウィンドウスタイル	wndCls.lpfnWndProc 	  = WndProc;                                            // ウィンドウのメッセージを処理するコールバック関数へのポインタ	wndCls.cbClsExtra	  = 0;                                                  // ウインドウクラス構造体の後ろに割り当てる補足バイト数(通常0)	wndCls.cbWndExtra	  = 0;                                                  // ウインドウインスタンスの後ろに割り当てる補足バイト数(通常0)	wndCls.hInstance	  = hInstance;                                          // ??? ウインドウクラスのためのウインドウプロシージャがあるインスタンスハンドル	wndCls.hIcon		  = LoadIcon(hInstance, MAKEINTRESOURCE(RES_ID_IMG_ICON));  // アイコン(不要なら第1引数にNULLを指定する)	wndCls.hCursor		  = LoadCursor(NULL, IDC_ARROW);                        // マウスカーソルのハンドル	wndCls.hbrBackground  = (HBRUSH)GetStockObject(WHITE_BRUSH);              // ウインドウ背景色(背景描画用ブラシのハンドル)	wndCls.lpszMenuName	  = NULL;	wndCls.lpszClassName  = CLASS_NAME_CHAT_WINDOW;	// ウィンドウクラスの登録	if (!RegisterClass(&wndCls)) {		MessageBox(hWnd, TEXT("RegisterClass() failed ..."), TEXT("Error"), MB_OK|MB_ICONERROR);		return -1;	}	/*** ウィンドウの定義 ***********************************************************************/	// https://msdn.microsoft.com/ja-jp/library/cc410713.aspx	// http://chokuto.ifdef.jp/urawaza/prm/window_style.html	hWnd = CreateWindow(			CLASS_NAME_CHAT_WINDOW,       // 登録されているクラス名			TEXT("LAN ChatTool"),               // キャプション			WS_OVERLAPPEDWINDOW |               // 下記全てを指定した場合と同等。													// WS_OVERLAPPED  オーバーラップウィンドウとして作成する。オーバーラップウィンドウ = タイトルと枠を持つ。													// WS_CAPTION     タイトルバーを持たせる（WS_BORDER | WS_DLGFRAME）													// WS_SYSMENU     タイトルバー上にウィンドウメニューボックスを持たせる													// WS_THICKFRAME  サイズ変更境界を持たせる													// WS_MINIMIZEBOX 最小化ボタンを持たせる													// WS_MAXIMIZEBOX 最大化ボタンを持たせる				WS_VISIBLE ,                    // 可視状態にする			CW_USEDEFAULT,CW_USEDEFAULT,        // 座標 X,Y			1050,850,                           // 幅、高さ			NULL,                               // 親ウィンドウまたはオーナーウィンドウのハンドル			NULL,                               // メニューハンドルまたは子ウィンドウ ID			hInstance,                          // アプリケーションインスタンスのハンドル			NULL                                // 作成時の引数保存用ポインタ	);	/*********************************************************************************************/	// ウィンドウの作成に失敗	if (hWnd == NULL) {		MessageBox(hWnd, TEXT("CreateWindow() failed ..."), TEXT("Error"), MB_OK|MB_ICONERROR);		return -1;	}	// スレッドを起動	if(startThread() != 0) {		errorlog(TEXT("サーバーリクエスト監視のスレッド作成に失敗しました。"));		return -1;	}	// スレッドを起動	if(startThread2() != 0) {		errorlog(TEXT("サーバーリクエスト監視のスレッド作成に失敗しました。"));		return -1;	}	while(GetMessage(&msg , NULL , 0 , 0)) {		TranslateMessage(&msg);		DispatchMessage(&msg);	}	return msg.wParam;}LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp) {	switch (msg) {	case WM_DESTROY:		PostQuitMessage(0);		return 0;	case WM_CREATE:		InitCommonControls();		InitControls(hWnd);		return 0;	case WM_SIZE:		SendMessage(hStatus , msg , wp , lp);		return 0;	//	case WM_COMMAND:		switch(LOWORD(wp)) {		// 送信ボタンを押下時		case CTL_ID_BTN_SEND:			sendbtn_click(hWnd);			break;		// 終了ボタンを押下時		case CTL_ID_BTN_EXIT:			break;		}		return 0;	}	return DefWindowProc(hWnd , msg , wp , lp);}/** * 各ウィンドウ(コントロール)の初期化処理を行う. * * @param hWnd ウィンドウインスタンス * */void InitControls(HWND hWnd) {	TCHAR buf[1024];	PROP_T prop;	// プロパティファイルの読込	int ret = loadPropery(SETTING_FILE_PATH, &prop);	// 読込失敗時	if (ret != 0) {		SetStatusText(TEXT("プロパティファイルが見つかりませんでした。"));		errorlog(TEXT("ファイルが見つかりません。 ファイルパス:[%s]"), SETTING_FILE_PATH);	// 読込成功時	} else {		// プロパティを取得		getValue(&prop, TEXT("user.name"), userName);		infolog(TEXT("指定されたキーに対応するプロパティ値を取得しました。filePath:[%s] key:[%s] buf:[%s]"), SETTING_FILE_PATH, TEXT("user.name"), buf);		// 取得失敗		if (_tcslen(buf) <= 0) {			SetStatusText(TEXT("指定されたキーに対応するプロパティ値が見つかりませんでした。"));		}	}	//HFONT hFnt;     //フォントのハンドル    /*** ステータスバーの定義 ***************************************************/	// http://wisdom.sakura.ne.jp/system/winapi/common/common9.html	// http://chokuto.ifdef.jp/urawaza/prm/comCTL_ID_style.html	hStatus = CreateStatusWindow(		WS_CHILD |                 // 親ウィンドウの小ウィンドウとして登録			WS_VISIBLE |           // 可視状態にする			CCS_BOTTOM |           // 親ウィンドウの下端に作成する			SBARS_SIZEGRIP ,       // 右端にサイズグリップを持たせる		TEXT("Start Window ..."),  // キャプション		hWnd,		1	);    /*** [エディットボックス] メッセージボックスの定義 *******************************************************/	CreateWindow(            TEXT("EDIT"),           // ウィンドウクラス名            NULL,                   // キャプション            WS_CHILD |              // 親ウィンドウの小ウィンドウとして登録				WS_VISIBLE |        // 可視状態にする				WS_BORDER |         // 境界線を設定				WS_HSCROLL |        // 水平スクロールバーを設定				WS_VSCROLL |        // 垂直スクロールバーを設定				ES_AUTOHSCROLL |    //				ES_AUTOVSCROLL |    //                ES_LEFT |           // テキストを左寄せ				ES_MULTILINE,       // 複数行            0,580,                  // 座標 X,Y            720,100,                // 幅、高さ            hWnd,                   // 親ウィンドウ			(HMENU)CTL_ID_EDIT_MSG,    // メニューハンドルまたは子ウィンドウID            hInst,                  // インスタンスハンドル            NULL);                  // その他の作成データ    /*    //テキストエディットのフォント作成    hFnt = CreateFont(14, 0, 0, 0,            FW_NORMAL, FALSE, FALSE, 0,            SHIFTJIS_CHARSET,            OUT_DEFAULT_PRECIS,            CLIP_DEFAULT_PRECIS,            DEFAULT_QUALITY, FIXED_PITCH, _T("System"));    //テキストエディットのフォント変更のメッセージを送信    SendMessage(hEdit, WM_SETFONT, (WPARAM)hFnt, MAKELPARAM(FALSE, 0));     */    /*** [ボタン] 送信ボタンの定義 *******************************************************/	CreateWindow(            TEXT("BUTTON"),        // ウィンドウクラス名			TEXT("送信"),          // キャプション			BS_PUSHBUTTON |        // プッシュボタン(BS_DEFPUSHBUTTONだと黒フチをつける)            	WS_CHILD |         // 親ウィンドウの小ウィンドウとして登録				WS_VISIBLE,        // 可視状態にする            620,700,               // 座標 X,Y			180,60,                 // 幅、高さ            hWnd,                   // 親ウィンドウ			(HMENU)CTL_ID_BTN_SEND,    // メニューハンドルまたは子ウィンドウID            hInst,                  // インスタンスハンドル			NULL);                  // その他の作成データ	/*** [ボタン] 終了ボタンの定義 *******************************************************/	CreateWindow(            TEXT("BUTTON"),         // ウィンドウクラス名			TEXT("終了"),           // キャプション			BS_PUSHBUTTON |         // プッシュボタン(BS_DEFPUSHBUTTONだと黒フチをつける)            	WS_CHILD |          // 親ウィンドウの小ウィンドウとして登録				WS_VISIBLE,         // 可視状態にする			820,700,                // 座標 X,Y            180,60,                 // 幅、高さ            hWnd,                   // 親ウィンドウ			(HMENU)CTL_ID_BTN_EXIT,    // メニューハンドルまたは子ウィンドウID            hInst,                  // インスタンスハンドル			NULL);                  // その他の作成データ	/*** [リストビュー] メンバーリストの定義 *******************************************************/	hListMember = CreateWindowEx(			0,			WC_LISTVIEW,			TEXT(""),	        WS_CHILD |				WS_VISIBLE |				LVS_REPORT |				WS_BORDER,         // 境界線を設定	        760,0,   // 座標 X,Y			220,560, // 幅、高さ			hWnd,			(HMENU)CTL_ID_LIST_MEMBER,			hInst,			NULL);	TCHAR *MEMBER_LIST_CAPTION[] = {TEXT("ユーザ一覧")};	int MEMBER_LIST_CX[] =         {220};	int MEMBER_LIST_FMT[] =        {LVCFMT_LEFT};    for (int c = 0; c < sizeof(MEMBER_LIST_CAPTION) / sizeof(TCHAR*); c++) {    	LVCOLUMN col;        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;        col.fmt      = MEMBER_LIST_FMT[c];        col.cx       = MEMBER_LIST_CX[c];        col.pszText = MEMBER_LIST_CAPTION[c];		col.iSubItem = c;		ListView_InsertColumn(hListMember, c, &col);    }    DWORD dwStyle;    dwStyle = ListView_GetExtendedListViewStyle(hListMember);    dwStyle |= LVS_EX_FULLROWSELECT;    ListView_SetExtendedListViewStyle(hListMember, dwStyle);	/*** [リストビュー] チャットリストの定義 *******************************************************/	hListMsg = CreateWindowEx(			0,			WC_LISTVIEW,			TEXT(""),	        WS_CHILD |				WS_VISIBLE |				LVS_REPORT |				WS_BORDER,         // 境界線を設定				//LVS_OWNERDATA,	        0,0,     // 座標 X,Y			720,560, // 幅、高さ			hWnd,			(HMENU)CTL_ID_LIST_MSG,			hInst,			NULL);	TCHAR *MSG_LIST_CAPTION[] = {TEXT("日付"), TEXT("ユーザ名"), TEXT("メッセージ")};	int MSG_LIST_CX[] =         {140,          140,              440};	int MSG_LIST_FMT[] =        {LVCFMT_LEFT,  LVCFMT_LEFT,      LVCFMT_LEFT};    for (int c = 0; c < sizeof(MSG_LIST_CAPTION) / sizeof(TCHAR*); c++) {    	LVCOLUMN col;        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;        col.fmt      = MSG_LIST_FMT[c];        col.cx       = MSG_LIST_CX[c];        col.pszText  = MSG_LIST_CAPTION[c];		col.iSubItem = c;		ListView_InsertColumn(hListMsg, c, &col);    }    DWORD dwStyle2;    dwStyle2 = ListView_GetExtendedListViewStyle(hListMsg);    dwStyle2 |= LVS_EX_FULLROWSELECT;    ListView_SetExtendedListViewStyle(hListMsg, dwStyle2);    /*	time_t timer;	time(&timer);	struct tm *ts = localtime(&timer);    POST_MSG_T msgs[25] = {    		{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts},			{TEXT("sasasasa"), TEXT("msg11111111111111"), NULL, *ts}    };    for (int i = 0; i < sizeof(msgs) / sizeof(msgs[0]); i++) {    	//postMessage(&msgs[i]);    }    */	if (isPlayedBGM == 0) {		//PlaySound(RES_SOUND_MAIN), NULL, (SND_ASYNC|SND_FILENAME) );		isPlayedBGM = 1;	}	// MessageBox(hWnd, buf, TEXT("あああああああああ"), MB_OK);}/** * 送信」ボタン押下時に実行する. * @param hWnd ウィンドウインスタンス * */void sendbtn_click(HWND hWnd) {	TCHAR sendMsg[1024];	// エディットボックスから送信メッセージを取得	GetDlgItemText(hWnd, CTL_ID_EDIT_MSG, (TCHAR*)sendMsg, sizeof(sendMsg) / sizeof(TCHAR));	// メッセージが未入力か	if (_tcslen(sendMsg) <= 0 || sendMsg[0] == TEXT('\0')) {		SetStatusText(TEXT("メッセージを入力して下さい。"));		return;	}    // メッセージを投稿    int r = sendSocketToClient(sendMsg, sizeof(sendMsg));    if (r != 0) {    	SetStatusText(TEXT("サーバーへのメッセージ送信に失敗しました。"));    	errorlog(TEXT("サーバーへのメッセージ送信に失敗しました。"));    	return;    }	time_t timer;	POST_MSG_T postMsg;	time(&timer);	struct tm *ts = localtime(&timer);    // chat構造体に値を設定	lstrcpy(postMsg.userName, TEXT("sugi"));    lstrcpy(postMsg.postMsg, sendMsg);    postMsg.postTime  = *ts;    postMsg.next = NULL;	postMessage(&postMsg);    SetStatusText(TEXT("メッセージを送信しました。"));	// エディットボックスの内容をクリア	SetDlgItemText(hWnd, CTL_ID_EDIT_MSG, NULL);}/** *  ステータスバーに表示するメッセージを表示する。 * *  @param *msg ステータスバーに表示するメッセージ * */void SetStatusText(TCHAR *msg) {	SendMessage(hStatus , SB_SETTEXT, NOT_SPLIT_STATUS_BAR, (LPARAM)msg );}/** * 以下のメソッドを別スレッドで実行します *   - watchServerMessage() * * @return スレッド作成成功(0) 失敗(0以外) * */intstartThread(void) {	int x = 1234;	pthread_t curThread;	// 第1引数：スレッド	// 第2引数：スレッド属性	// 第3引数：実行する関数	// 第4引数：関数に渡す引数	int ret = pthread_create(&curThread, NULL, watchServerMessage, (void*)&x);	return ret;}/** * サーバーからのリクエストを監視します。 * リクエストの種類によって処理を振り分けます。 * */voidwatchServerMessage(void) {	infolog(TEXT("メッセージ受信スレッドを開始します。%d"));	watchServerRequest();	/*	void *p = malloc(sizeof(int));	*(int*)(p) = 123;	pthread_exit(p);	if (threadStatus != 0) {		infolog(TEXT("メッセージ受信スレッドを終了します。ステータス：[%d]"), threadStatus);		pthread_exit(3);	}*/	infolog(TEXT("メッセージ受信スレッドを終了します。"));}